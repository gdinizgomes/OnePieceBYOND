<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <style>
        body { margin: 0; overflow: hidden; user-select: none; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        .char-info { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; color: white; border: 2px solid #d4af37; }
        .hp-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        .bar-container { width: 200px; height: 10px; background: #333; margin-top: 5px; overflow: hidden; }
        
        #combat-log { 
            position: absolute; bottom: 20px; right: 20px; width: 300px; height: 150px; 
            background: rgba(0,0,0,0.5); color: #fff; font-size: 12px; overflow-y: auto; 
            padding: 10px; border-radius: 5px; font-family: monospace; pointer-events: auto;
        }
        .log-hit { color: #e74c3c; font-weight: bold; } 
        .log-miss { color: #95a5a6; } 

        #notif-area { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); text-align: center; }
        .toast { background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px; margin-top: 5px; animation: fadeout 3s forwards; }
        @keyframes fadeout { 0% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui-layer">
        <div class="char-info">
            <div id="name-display" style="font-size: 18px; font-weight: bold;">Loading...</div>
            <div style="font-size: 12px; color: #aaa;">Lvl <span id="lvl-display">0</span></div>
            <div class="bar-container"><div id="hp-bar-fill" class="hp-bar"></div></div>
            <div style="margin-top:5px; color:#f1c40f">ðŸ’° <span id="gold-display">0</span> Berries</div>
        </div>
        <div id="notif-area"></div>
        <div id="combat-log">System: Combat Log Initialized.<br></div>
    </div>

    <script>
        // --- 1. CONFIGURAÃ‡ÃƒO THREE.JS ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 15, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const MAP_SIZE = 60; const MAP_LIMIT = MAP_SIZE / 2;
        const road = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), new THREE.MeshPhongMaterial({ color: 0x333333 }));
        road.rotation.x = -Math.PI / 2; road.receiveShadow = true;
        scene.add(road); scene.add(new THREE.GridHelper(MAP_SIZE, MAP_SIZE));

        // --- 2. TRONCO DE TREINO ---
        const dummyGroup = new THREE.Group();
        dummyGroup.position.set(5, 0, 5);
        
        const trunkGeo = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 12);
        const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 0.9; trunk.castShadow = true;
        
        const targetGeo = new THREE.CylinderGeometry(0.41, 0.41, 0.4, 12);
        const targetMat = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
        const target = new THREE.Mesh(targetGeo, targetMat);
        target.position.y = 1.3;
        
        const targetCenterGeo = new THREE.CylinderGeometry(0.42, 0.42, 0.2, 12);
        const targetCenterMat = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
        const targetCenter = new THREE.Mesh(targetCenterGeo, targetCenterMat);
        targetCenter.position.y = 1.3;

        dummyGroup.add(trunk); dummyGroup.add(target); dummyGroup.add(targetCenter);
        scene.add(dummyGroup);

        // --- 3. PLAYER RIG ---
        const playerGroup = new THREE.Group();
        playerGroup.visible = false; 
        
        let matSkin = new THREE.MeshPhongMaterial({ color: 0xFFCCAA }); 
        let matClothes = new THREE.MeshPhongMaterial({ color: 0xCC0000 }); 

        const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), matClothes);
        torso.position.y = 1.1; torso.castShadow = true; playerGroup.add(torso);
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.35), matSkin);
        head.position.y = 0.55; torso.add(head);

        const eyeGeo = new THREE.BoxGeometry(0.05, 0.05, 0.05); const matEye = new THREE.MeshBasicMaterial({color: 0x000000});
        const eyeL = new THREE.Mesh(eyeGeo, matEye); eyeL.position.set(0.1, 0.05, 0.18); head.add(eyeL);
        const eyeR = new THREE.Mesh(eyeGeo, matEye); eyeR.position.set(-0.1, 0.05, 0.18); head.add(eyeR);

        function createLimb(w, h, d, mat, x, y, z) {
            const pivot = new THREE.Group(); pivot.position.set(x, y, z);
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.y = -h/2; mesh.castShadow = true; pivot.add(mesh); return { pivot, mesh };
        }
        const leftArm = createLimb(0.15, 0.7, 0.15, matSkin, 0.35, 0.3, 0); const rightArm = createLimb(0.15, 0.7, 0.15, matSkin, -0.35, 0.3, 0);
        const leftLeg = createLimb(0.18, 0.8, 0.18, matClothes, 0.12, -0.35, 0); const rightLeg = createLimb(0.18, 0.8, 0.18, matClothes, -0.12, -0.35, 0);
        torso.add(leftArm.pivot); torso.add(rightArm.pivot); torso.add(leftLeg.pivot); torso.add(rightLeg.pivot);
        scene.add(playerGroup);

        // --- 4. INPUTS ---
        const keys = { arrowup: false, arrowdown: false, arrowleft: false, arrowright: false, " ": false };
        let blockSync = false;

        document.addEventListener('keydown', e => { 
            const k = e.key.toLowerCase();
            if(keys.hasOwnProperty(k)) keys[k] = true;
            if(k === 'a') { performAttack(); }
            if(k === 'p' && !blockSync) {
                blockSync = true; 
                window.location.href = "byond://?src=" + BYOND_REF + "&action=force_save";
                addLog("System: Saving game...", "log-miss");
                setTimeout(() => { blockSync = false; }, 500);
            }
        });
        document.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });
        
        let camAngle = Math.PI; let mouseRight = false; let lastMouseX = 0;
        document.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('mousedown', e => { if(e.button===2){mouseRight=true; lastMouseX=e.clientX;} });
        document.addEventListener('mouseup', e => { if(e.button===2) mouseRight=false; });
        document.addEventListener('mousemove', e => { 
            if(mouseRight) { 
                camAngle -= (e.clientX - lastMouseX)*0.005; 
                lastMouseX=e.clientX; 
            } 
        });

        let isAttacking = false; let attackTimer = 0;
        function addLog(msg, cssClass) {
            const log = document.getElementById('combat-log');
            log.innerHTML += `<span class="${cssClass}">${msg}</span><br>`;
            log.scrollTop = log.scrollHeight;
        }

        function performAttack() {
            if(isAttacking) return; isAttacking = true; attackTimer = 0;
            const dist = playerGroup.position.distanceTo(dummyGroup.position);
            if(dist < 2.5) {
                addLog(`> HIT! (Dist: ${dist.toFixed(1)}m)`, "log-hit");
                targetCenter.material.color.setHex(0x550000);
                setTimeout(() => { targetCenter.material.color.setHex(0xFF0000); }, 150);
            } else {
                addLog(`> Miss. (Dist: ${dist.toFixed(1)}m)`, "log-miss");
            }
            blockSync = true;
            window.location.href = "byond://?src=" + BYOND_REF + "&action=attack";
            setTimeout(() => { blockSync = false; }, 200);
        }

        const BYOND_REF = "{{BYOND_REF}}";
        let firstLoad = true; let isCharacterReady = false;

        function receberDados(json) {
            const data = JSON.parse(json).data;
            if(data.skin) {
                matSkin.color.setHex("0x" + data.skin);
                matClothes.color.setHex("0x" + data.cloth);
            }
            if (data.loaded == 1) {
                isCharacterReady = true;
                playerGroup.visible = true;
                if (firstLoad) {
                    playerGroup.position.x = data.x;
                    playerGroup.position.z = data.z;
                    camAngle = data.rot + Math.PI; 
                    firstLoad = false;
                }
            }
            document.getElementById('name-display').innerText = data.name;
            document.getElementById('lvl-display').innerText = data.lvl;
            document.getElementById('gold-display').innerText = data.gold;
            const hpPercent = (data.hp / data.max_hp) * 100;
            document.getElementById('hp-bar-fill').style.width = hpPercent + "%";
        }

        setInterval(() => {
            if(!firstLoad && !blockSync && isCharacterReady) {
                const x = playerGroup.position.x.toFixed(2);
                const z = playerGroup.position.z.toFixed(2);
                const rot = playerGroup.rotation.y.toFixed(2);
                window.location.href = `byond://?src=${BYOND_REF}&action=update_pos&x=${x}&z=${z}&rot=${rot}`;
            }
        }, 200);

        function lerpAngle(start, end, t) {
            const diff = end - start;
            const shortestDiff = ((diff + Math.PI) % (Math.PI * 2)) - Math.PI;
            return start + shortestDiff * t;
        }

        // --- GAME LOOP ---
        let animTime = 0; let isJumping = false; let verticalVelocity = 0; const gravity = -0.015; const jumpForce = 0.3;
        
        function animate() {
            requestAnimationFrame(animate);
            animTime += 0.1;

            const speed = 0.15;
            let moveX = 0, moveZ = 0, moving = false;
            
            if (isCharacterReady) {
                const sin = Math.sin(camAngle); const cos = Math.cos(camAngle);
                
                if(keys.arrowup)    { moveX -= sin*speed; moveZ -= cos*speed; moving = true; }
                if(keys.arrowdown)  { moveX += sin*speed; moveZ += cos*speed; moving = true; }
                if(keys.arrowleft)  { moveX -= cos*speed; moveZ += sin*speed; moving = true; }
                if(keys.arrowright) { moveX += cos*speed; moveZ -= sin*speed; moving = true; }

                playerGroup.position.x += moveX; playerGroup.position.z += moveZ;

                if(playerGroup.position.x > MAP_LIMIT-1) playerGroup.position.x = MAP_LIMIT-1;
                if(playerGroup.position.x < -MAP_LIMIT+1) playerGroup.position.x = -MAP_LIMIT+1;
                if(playerGroup.position.z > MAP_LIMIT-1) playerGroup.position.z = MAP_LIMIT-1;
                if(playerGroup.position.z < -MAP_LIMIT+1) playerGroup.position.z = -MAP_LIMIT+1;

                if(moving) {
                    const targetCharRot = Math.atan2(moveX, moveZ);
                    playerGroup.rotation.y = targetCharRot;

                    // --- CÃ‚MERA HÃBRIDA ---
                    if(!keys.arrowdown && !mouseRight) {
                        const targetCamAngle = targetCharRot + Math.PI;
                        
                        // SE ANDAR PRA FRENTE: RÃ¡pido (0.02)
                        // SE ANDAR PRO LADO (Strafe): Muito Lento (0.005) -> Evita tontura
                        let turnSpeed = 0.005; 
                        if(keys.arrowup) turnSpeed = 0.02;

                        camAngle = lerpAngle(camAngle, targetCamAngle, turnSpeed); 
                    }
                }

                if(keys[" "] && !isJumping) { verticalVelocity = jumpForce; isJumping = true; }
                playerGroup.position.y += verticalVelocity; verticalVelocity += gravity;
                if(playerGroup.position.y < 0) { playerGroup.position.y = 0; isJumping = false; verticalVelocity = 0; }

                if(moving && !isJumping) {
                    leftLeg.pivot.rotation.x = Math.sin(animTime)*0.8; rightLeg.pivot.rotation.x = -Math.sin(animTime)*0.8; 
                    leftArm.pivot.rotation.x = -Math.sin(animTime)*0.8; rightArm.pivot.rotation.x = Math.sin(animTime)*0.8; 
                } else if (!isAttacking) {
                    leftLeg.pivot.rotation.x = 0; rightLeg.pivot.rotation.x = 0; leftArm.pivot.rotation.x = 0; rightArm.pivot.rotation.x = 0;
                }
            }

            if(isAttacking) {
                attackTimer += 0.2; rightArm.pivot.rotation.x = -Math.sin(attackTimer) * 2; 
                if(attackTimer > Math.PI) { isAttacking = false; rightArm.pivot.rotation.x = 0; }
            }

            const camDist = 7; const camH = 5;
            camera.position.x = playerGroup.position.x + Math.sin(camAngle)*camDist;
            camera.position.z = playerGroup.position.z + Math.cos(camAngle)*camDist;
            camera.position.y = playerGroup.position.y + camH;
            camera.lookAt(playerGroup.position.x, playerGroup.position.y + 1.5, playerGroup.position.z);

            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => { renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); };
    </script>
</body>
</html>