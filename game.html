<!DOCTYPE html>
<html>
<head>

    <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        const BYOND_REF = "{{BYOND_REF}}";
    </script>
    <script>
    // Detetive de Erros: Mostra erros na tela se o jogo falhar
    window.onerror = function(message, source, lineno, colno, error) {
        let errorBox = document.getElementById('error-debug');
        if (!errorBox) {
            errorBox = document.createElement('div');
            errorBox.id = 'error-debug';
            errorBox.style.position = 'fixed';
            errorBox.style.top = '0';
            errorBox.style.left = '0';
            errorBox.style.width = '100%';
            errorBox.style.background = 'red';
            errorBox.style.color = 'white';
            errorBox.style.zIndex = '9999';
            errorBox.style.padding = '10px';
            errorBox.style.fontFamily = 'monospace';
            document.body.appendChild(errorBox);
        }
        errorBox.innerHTML += "ERRO: " + message + " em " + source + ":" + lineno + "<br>";
    };
    </script>
    
</head>
<body>
    <div id="ui-layer">
        <div class="char-info">
            <div id="name-display" style="font-size: 18px; font-weight: bold;">Loading...</div>
            <div style="font-size: 12px; color: #aaa;">Lvl <span id="lvl-display">0</span></div>
            <div class="bar-container"><div id="hp-bar-fill" class="hp-bar"></div></div>
            <div style="margin-top:5px; color:#f1c40f">ðŸ’° <span id="gold-display">0</span> Berries</div>
        </div>
        <div id="notif-area"></div>
        <div id="combat-log">System: Multiplayer Core Active.<br></div>
        <div id="labels-container"></div>
    </div>

    <script src="definitions.js"></script> <script src="factory.js"></script>     <script src="engine.js"></script>
    <script src="input.js"></script>
    <script src="animation.js"></script>
    <script src="network.js"></script>

    <script>
        // --- GAME LOGIC ---
        let charState = "DEFAULT"; 
        let currentCombatMode = "DEFAULT"; 
        let lastCombatActionTime = 0; 
        let isAttacking = false; 

        let animTime = 0; 
        let isJumping = false; 
        let verticalVelocity = 0; 
        const gravity = -0.015; 
        const jumpForce = 0.3;

        function addLog(msg, css) { const d = document.getElementById('combat-log'); d.innerHTML += `<span class="${css}">${msg}</span><br>`; d.scrollTop=d.scrollHeight; }

        window.addEventListener('game-action', (e) => {
            const k = e.detail;
            // Equipar itens para teste ao atacar
            if(k === 'd') { CharFactory.equipItem(playerGroup, "weapon_sword_iron"); performAttack("sword"); }
            else if(k === 'f') { CharFactory.equipItem(playerGroup, "weapon_gun_flintlock"); performAttack("gun"); }
            else if(k === 'a') { performAttack("fist"); } // MÃ£os limpas
            else if(k === 's') { performAttack("kick"); }
            
            else if(k === 'p' && !blockSync) {
                blockSync = true; 
                window.location.href = "byond://?src=" + BYOND_REF + "&action=force_save";
                addLog("Salvando...", "log-miss");
                setTimeout(() => { blockSync = false; }, 500);
            }
        });

        function performAttack(type) {
            if(isAttacking || !isCharacterReady) return; 
            isAttacking = true;
            lastCombatActionTime = Date.now();

            let windupStance = "SWORD_WINDUP";
            let atkStance = "SWORD_ATK_1";
            let idleStance = "SWORD_IDLE";

            if(type === "fist") { windupStance = "FIST_WINDUP"; atkStance = "FIST_ATK"; idleStance = "FIST_IDLE"; }
            else if(type === "kick") { windupStance = "KICK_WINDUP"; atkStance = "KICK_ATK"; idleStance = "FIST_IDLE"; }
            else if(type === "sword") { windupStance = "SWORD_WINDUP"; atkStance = "SWORD_ATK_1"; idleStance = "SWORD_IDLE"; }
            else if(type === "gun") { windupStance = "GUN_IDLE"; atkStance = "GUN_ATK"; idleStance = "GUN_IDLE"; }

            charState = windupStance; 

            setTimeout(() => {
                charState = atkStance;
                
                let dist = 100;
                if(Engine.dummyTarget) {
                    dist = playerGroup.position.distanceTo(Engine.dummyTarget.position);
                }

                if(dist < (type === "gun" ? 8.0 : 2.5)) { 
                    addLog(`HIT (${type})!`, "log-hit"); 
                    if(Engine.dummyTarget && Engine.dummyTarget.userData.hitZone) {
                        const mat = Engine.dummyTarget.userData.hitZone.material;
                        mat.color.setHex(0x550000); 
                        setTimeout(()=>mat.color.setHex(0xFF0000),150);
                    }
                } else {
                    addLog("Errou...", "log-miss");
                }
                
                blockSync = true; 
                window.location.href = `byond://?src=${BYOND_REF}&action=attack&type=${type}`; 
                setTimeout(()=>{blockSync=false}, 200);

                setTimeout(() => {
                    charState = idleStance; 
                    isAttacking = false;
                }, 300);
            }, 100); 
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            animTime += 0.1;
            const now = performance.now();

            if (isCharacterReady) {
                if(!isAttacking && charState !== "DEFAULT") {
                    if(Date.now() - lastCombatActionTime > 3000) charState = "DEFAULT";
                }

                const speed = 0.15;
                let moveX = 0, moveZ = 0, moving = false;
                const sin = Math.sin(Input.camAngle); const cos = Math.cos(Input.camAngle);
                
                if(Input.keys.arrowup) { moveX -= sin*speed; moveZ -= cos*speed; moving = true; }
                if(Input.keys.arrowdown) { moveX += sin*speed; moveZ += cos*speed; moving = true; }
                if(Input.keys.arrowleft) { moveX -= cos*speed; moveZ += sin*speed; moving = true; }
                if(Input.keys.arrowright) { moveX += cos*speed; moveZ -= sin*speed; moving = true; }

                playerGroup.position.x += moveX; playerGroup.position.z += moveZ;
                if(playerGroup.position.x > 30) playerGroup.position.x = 30; if(playerGroup.position.x < -30) playerGroup.position.x = -30;
                if(playerGroup.position.z > 30) playerGroup.position.z = 30; if(playerGroup.position.z < -30) playerGroup.position.z = -30;

                if(moving) {
                    const targetCharRot = Math.atan2(moveX, moveZ);
                    playerGroup.rotation.y = targetCharRot;
                    if(!Input.keys.arrowdown && !Input.mouseRight) Input.camAngle = lerpAngle(Input.camAngle, targetCharRot + Math.PI, 0.02);
                }

                if(Input.keys[" "] && !isJumping) { verticalVelocity = jumpForce; isJumping = true; }
                playerGroup.position.y += verticalVelocity; verticalVelocity += gravity;
                if(playerGroup.position.y < 0) { playerGroup.position.y = 0; isJumping = false; verticalVelocity = 0; }

                // AnimaÃ§Ã£o Local
                let targetStance = STANCES[charState] || STANCES.DEFAULT;
                if(moving && !isJumping && !isAttacking) {
                    playerGroup.userData.limbs.leftLeg.rotation.x = Math.sin(animTime)*0.8;
                    playerGroup.userData.limbs.rightLeg.rotation.x = -Math.sin(animTime)*0.8;
                    
                    if(charState === "DEFAULT") {
                        playerGroup.userData.limbs.leftArm.rotation.x = -Math.sin(animTime)*0.8;
                        playerGroup.userData.limbs.rightArm.rotation.x = Math.sin(animTime)*0.8;
                    } else {
                        lerpLimbRotation(playerGroup.userData.limbs.leftArm, targetStance.leftArm, 0.2);
                        lerpLimbRotation(playerGroup.userData.limbs.rightArm, targetStance.rightArm, 0.2);
                    }
                } else {
                    const animSpeed = isAttacking ? 0.4 : 0.1;
                    lerpLimbRotation(playerGroup.userData.limbs.leftArm, targetStance.leftArm, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.rightArm, targetStance.rightArm, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.leftLeg, targetStance.leftLeg, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.rightLeg, targetStance.rightLeg, animSpeed);
                }

                // CÃ¢mera
                const camDist = 7; const camH = 5;
                Engine.camera.position.set(
                    playerGroup.position.x + Math.sin(Input.camAngle)*camDist, 
                    playerGroup.position.y + camH, 
                    playerGroup.position.z + Math.cos(Input.camAngle)*camDist
                );
                Engine.camera.lookAt(playerGroup.position.x, playerGroup.position.y + 1.5, playerGroup.position.z);

                sendPositionUpdate(now);
            }

            // AnimaÃ§Ã£o Remota
            for(const id in otherPlayers) {
                const other = otherPlayers[id];
                const mesh = other.mesh;
                const elapsed = other.lastPacketTime ? (now - other.lastPacketTime) : 0;
                const t = other.lerpDuration ? Math.min(1, elapsed / other.lerpDuration) : 1;
                
                mesh.position.x = lerp(other.startX, other.targetX, t);
                mesh.position.y = lerp(other.startY, other.targetY, t);
                mesh.position.z = lerp(other.startZ, other.targetZ, t);
                mesh.rotation.y = lerpAngle(other.startRot, other.targetRot, t);

                const dist = Math.sqrt(Math.pow(other.targetX - mesh.position.x, 2) + Math.pow(other.targetZ - mesh.position.z, 2));
                const isMoving = dist > 0.05;

                let remoteStance = STANCES.DEFAULT; 
                const timeSinceCombat = now - (other.lastCombatTime || 0);
                const isInCombatMode = timeSinceCombat < 3000;

                if(isInCombatMode) {
                    let type = other.lastCombatType || "sword";
                    if(type === "fist" || type === "kick") remoteStance = STANCES.FIST_IDLE;
                    else if(type === "gun") remoteStance = STANCES.GUN_IDLE;
                    else remoteStance = STANCES.SWORD_IDLE;
                }

                if(other.attacking) {
                    let atkName = "SWORD_ATK_1";
                    let currentType = other.attackType || other.lastCombatType;
                    if(currentType === "fist") atkName = "FIST_ATK";
                    if(currentType === "kick") atkName = "KICK_ATK";
                    if(currentType === "gun") atkName = "GUN_ATK";
                    
                    let targetAnim = STANCES[atkName] || STANCES.SWORD_ATK_1;
                    lerpLimbRotation(mesh.userData.limbs.leftArm, targetAnim.leftArm, 0.3);
                    lerpLimbRotation(mesh.userData.limbs.rightArm, targetAnim.rightArm, 0.3);
                    lerpLimbRotation(mesh.userData.limbs.leftLeg, targetAnim.leftLeg, 0.3);
                    lerpLimbRotation(mesh.userData.limbs.rightLeg, targetAnim.rightLeg, 0.3);
                } else {
                    if(isMoving) {
                        mesh.userData.limbs.leftLeg.rotation.x = Math.sin(animTime)*0.8;
                        mesh.userData.limbs.rightLeg.rotation.x = -Math.sin(animTime)*0.8;
                        if(remoteStance === STANCES.DEFAULT) {
                            mesh.userData.limbs.leftArm.rotation.x = -Math.sin(animTime)*0.8;
                            mesh.userData.limbs.rightArm.rotation.x = Math.sin(animTime)*0.8;
                        } else {
                            lerpLimbRotation(mesh.userData.limbs.leftArm, remoteStance.leftArm, 0.2);
                            lerpLimbRotation(mesh.userData.limbs.rightArm, remoteStance.rightArm, 0.2);
                        }
                    } else {
                        lerpLimbRotation(mesh.userData.limbs.leftArm, remoteStance.leftArm, 0.1);
                        lerpLimbRotation(mesh.userData.limbs.rightArm, remoteStance.rightArm, 0.1);
                        lerpLimbRotation(mesh.userData.limbs.leftLeg, remoteStance.leftLeg, 0.1);
                        lerpLimbRotation(mesh.userData.limbs.rightLeg, remoteStance.rightLeg, 0.1);
                    }
                }
                
                const tempV = new THREE.Vector3(mesh.position.x, mesh.position.y + 2, mesh.position.z);
                tempV.project(Engine.camera);
                other.label.style.display = (Math.abs(tempV.z) > 1) ? 'none' : 'block';
                other.label.style.left = (tempV.x * .5 + .5) * window.innerWidth + 'px';
                other.label.style.top = (-(tempV.y * .5) + .5) * window.innerHeight + 'px';
            }

            Engine.renderer.render(Engine.scene, Engine.camera);
        }
        animate();
    </script>
</body>
</html>