<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <style>
        body { margin: 0; overflow: hidden; user-select: none; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        .char-info { position: absolute; top: 20px; left: 20px; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; color: white; border: 2px solid #d4af37; }
        .hp-bar { width: 100%; height: 100%; background: #e74c3c; transition: width 0.2s; }
        .bar-container { width: 200px; height: 10px; background: #333; margin-top: 5px; overflow: hidden; }
        
        #combat-log { 
            position: absolute; bottom: 20px; right: 20px; width: 300px; height: 150px; 
            background: rgba(0,0,0,0.5); color: #fff; font-size: 12px; overflow-y: auto; 
            padding: 10px; border-radius: 5px; font-family: monospace; pointer-events: auto;
        }
        .log-hit { color: #e74c3c; font-weight: bold; } 
        .log-miss { color: #95a5a6; } 

        #notif-area { position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); text-align: center; }
        .toast { background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px; margin-top: 5px; animation: fadeout 3s forwards; }
        @keyframes fadeout { 0% { opacity: 1; } 80% { opacity: 1; } 100% { opacity: 0; } }
        
        /* Nomes flutuantes */
        .name-label {
            position: absolute; color: white; background: rgba(0,0,0,0.5); padding: 2px 5px; 
            border-radius: 4px; font-size: 10px; pointer-events: none;
            text-shadow: 1px 1px 0 #000; display: none; /* Controlado pelo JS */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="ui-layer">
        <div class="char-info">
            <div id="name-display" style="font-size: 18px; font-weight: bold;">Loading...</div>
            <div style="font-size: 12px; color: #aaa;">Lvl <span id="lvl-display">0</span></div>
            <div class="bar-container"><div id="hp-bar-fill" class="hp-bar"></div></div>
            <div style="margin-top:5px; color:#f1c40f">üí∞ <span id="gold-display">0</span> Berries</div>
        </div>
        <div id="notif-area"></div>
        <div id="combat-log">System: Multiplayer Core Active.<br></div>
        <div id="labels-container"></div>
    </div>

    <script>
        // --- 1. CONFIGURA√á√ÉO B√ÅSICA ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 15, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(20, 50, 20);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const MAP_SIZE = 60;
        const MAP_LIMIT = MAP_SIZE / 2;

        const road = new THREE.Mesh(
            new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE),
            new THREE.MeshPhongMaterial({ color: 0x333333 })
        );
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        scene.add(road);
        scene.add(new THREE.GridHelper(MAP_SIZE, MAP_SIZE));

        // --- 2. TRONCO DE TREINO ---
        const dummyGroup = new THREE.Group();
        dummyGroup.position.set(5, 0, 5);

        const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.4, 1.8, 12),
            new THREE.MeshPhongMaterial({ color: 0x8B4513 })
        );
        trunk.position.y = 0.9;
        trunk.castShadow = true;

        const target = new THREE.Mesh(
            new THREE.CylinderGeometry(0.41, 0.41, 0.4, 12),
            new THREE.MeshBasicMaterial({ color: 0xFFFFFF })
        );
        target.position.y = 1.3;

        const targetCenter = new THREE.Mesh(
            new THREE.CylinderGeometry(0.42, 0.42, 0.2, 12),
            new THREE.MeshBasicMaterial({ color: 0xFF0000 })
        );
        targetCenter.position.y = 1.3;

        dummyGroup.add(trunk, target, targetCenter);
        scene.add(dummyGroup);

        // --- 3. F√ÅBRICA DE PERSONAGENS (Reutiliz√°vel) ---
        function createCharacterMesh(skinColorHex, clothColorHex) {
            const group = new THREE.Group();

            const matSkin = new THREE.MeshPhongMaterial({ color: parseInt(`0x${skinColorHex}`, 16) });
            const matClothes = new THREE.MeshPhongMaterial({ color: parseInt(`0x${clothColorHex}`, 16) });
            const matEye = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.7, 0.3), matClothes);
            torso.position.y = 1.1;
            torso.castShadow = true;
            group.add(torso);

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.35), matSkin);
            head.position.y = 0.55;
            torso.add(head);

            const eyeL = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), matEye);
            eyeL.position.set(0.1, 0.05, 0.18);
            head.add(eyeL);

            const eyeR = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.05, 0.05), matEye);
            eyeR.position.set(-0.1, 0.05, 0.18);
            head.add(eyeR);

            function createLimb(w, h, d, mat, x, y, z) {
                const pivot = new THREE.Group();
                pivot.position.set(x, y, z);
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                mesh.position.y = -h / 2;
                mesh.castShadow = true;
                pivot.add(mesh);
                return { pivot, mesh };
            }

            const leftArm = createLimb(0.15, 0.7, 0.15, matSkin, 0.35, 0.3, 0);
            const rightArm = createLimb(0.15, 0.7, 0.15, matSkin, -0.35, 0.3, 0);
            const leftLeg = createLimb(0.18, 0.8, 0.18, matClothes, 0.12, -0.35, 0);
            const rightLeg = createLimb(0.18, 0.8, 0.18, matClothes, -0.12, -0.35, 0);

            torso.add(leftArm.pivot, rightArm.pivot, leftLeg.pivot, rightLeg.pivot);

            group.userData.limbs = {
                leftArm: leftArm.pivot,
                rightArm: rightArm.pivot,
                leftLeg: leftLeg.pivot,
                rightLeg: rightLeg.pivot,
            };

            return group;
        }

        // --- 4. GERENCIAMENTO MULTIPLAYER ---
        const state = {
            playerGroup: null,
            otherPlayers: {},
            myID: null,
            isCharacterReady: false,
            blockSync: false,
            camAngle: Math.PI,
            mouseRight: false,
            lastMouseX: 0,
            isJumping: false,
            verticalVelocity: 0,
            isAttacking: false,
            attackTimer: 0,
            animTime: 0,
        };

        const INPUT_KEYS = {
            arrowup: false,
            arrowdown: false,
            arrowleft: false,
            arrowright: false,
            " ": false,
        };

        const CONFIG = {
            speed: 0.15,
            gravity: -0.015,
            jumpForce: 0.3,
            camDist: 7,
            camHeight: 5,
            attackRange: 2.5,
            attackAnimSpeed: 0.2,
            animTimeStep: 0.1,
            interpFactor: 0.1,
            syncIntervalMs: 200,
        };

        const UI = {
            name: document.getElementById('name-display'),
            level: document.getElementById('lvl-display'),
            gold: document.getElementById('gold-display'),
            hpBar: document.getElementById('hp-bar-fill'),
            log: document.getElementById('combat-log'),
            labels: document.getElementById('labels-container'),
        };

        const BYOND_REF = "{{BYOND_REF}}";

        function addLog(msg, css) {
            UI.log.innerHTML += `<span class="${css}">${msg}</span><br>`;
            UI.log.scrollTop = UI.log.scrollHeight;
        }

        function updateHud(packet, me) {
            const meFromOthers = packet.others[state.myID];
            UI.name.innerText = meFromOthers ? meFromOthers.name : "Loading";
            UI.level.innerText = me.lvl;
            UI.gold.innerText = me.gold;
            UI.hpBar.style.width = `${(me.hp / me.max_hp) * 100}%`;
        }

        function initLocalPlayer(packet) {
            if (!packet.others[state.myID]) return;
            const myData = packet.others[state.myID];
            state.playerGroup = createCharacterMesh(myData.skin, myData.cloth);
            state.playerGroup.visible = true;
            state.playerGroup.position.set(myData.x, 0, myData.z);
            scene.add(state.playerGroup);
            state.isCharacterReady = true;
            state.camAngle = myData.rot + Math.PI;
        }

        function ensureRemotePlayer(id, pData) {
            const newChar = createCharacterMesh(pData.skin, pData.cloth);
            newChar.position.set(pData.x, 0, pData.z);
            scene.add(newChar);

            const label = document.createElement('div');
            label.className = 'name-label';
            label.innerText = pData.name;
            UI.labels.appendChild(label);

            state.otherPlayers[id] = {
                mesh: newChar,
                label,
                targetX: pData.x,
                targetZ: pData.z,
                targetRot: pData.rot,
            };

            addLog(`${pData.name} entrou na √°rea.`, "log-miss");
        }

        function updateRemoteTargets(serverPlayers) {
            for (const id in serverPlayers) {
                if (id === state.myID) continue;
                const pData = serverPlayers[id];

                if (!state.otherPlayers[id]) {
                    ensureRemotePlayer(id, pData);
                } else {
                    const other = state.otherPlayers[id];
                    other.targetX = pData.x;
                    other.targetZ = pData.z;
                    other.targetRot = pData.rot;
                }
            }

            for (const id in state.otherPlayers) {
                if (!serverPlayers[id]) {
                    scene.remove(state.otherPlayers[id].mesh);
                    state.otherPlayers[id].label.remove();
                    delete state.otherPlayers[id];
                }
            }
        }

        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        function lerpAngle(start, end, t) {
            const diff = end - start;
            const shortestDiff = ((diff + Math.PI) % (Math.PI * 2)) - Math.PI;
            return start + shortestDiff * t;
        }

        function animateLimb(limbs, moving, time, attacking, attackTimer) {
            if (moving) {
                limbs.leftLeg.rotation.x = Math.sin(time) * 0.8;
                limbs.rightLeg.rotation.x = -Math.sin(time) * 0.8;
                limbs.leftArm.rotation.x = -Math.sin(time) * 0.8;
                limbs.rightArm.rotation.x = Math.sin(time) * 0.8;
            } else if (!attacking) {
                limbs.leftLeg.rotation.x = 0;
                limbs.rightLeg.rotation.x = 0;
                limbs.leftArm.rotation.x = 0;
                limbs.rightArm.rotation.x = 0;
            }

            if (attacking) {
                limbs.rightArm.rotation.x = -Math.sin(attackTimer) * 2;
            }
        }

        function moveLocalPlayer() {
            const sin = Math.sin(state.camAngle);
            const cos = Math.cos(state.camAngle);
            let moveX = 0;
            let moveZ = 0;
            let moving = false;

            if (INPUT_KEYS.arrowup) {
                moveX -= sin * CONFIG.speed;
                moveZ -= cos * CONFIG.speed;
                moving = true;
            }

            if (INPUT_KEYS.arrowdown) {
                moveX += sin * CONFIG.speed;
                moveZ += cos * CONFIG.speed;
                moving = true;
            }

            if (INPUT_KEYS.arrowleft) {
                moveX -= cos * CONFIG.speed;
                moveZ += sin * CONFIG.speed;
                moving = true;
            }

            if (INPUT_KEYS.arrowright) {
                moveX += cos * CONFIG.speed;
                moveZ -= sin * CONFIG.speed;
                moving = true;
            }

            state.playerGroup.position.x += moveX;
            state.playerGroup.position.z += moveZ;

            state.playerGroup.position.x = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, state.playerGroup.position.x));
            state.playerGroup.position.z = Math.max(-MAP_LIMIT, Math.min(MAP_LIMIT, state.playerGroup.position.z));

            if (moving) {
                const targetCharRot = Math.atan2(moveX, moveZ);
                state.playerGroup.rotation.y = targetCharRot;

                if (INPUT_KEYS.arrowup && !state.mouseRight) {
                    state.camAngle = lerpAngle(state.camAngle, targetCharRot + Math.PI, 0.02);
                }
            }

            if (INPUT_KEYS[" "] && !state.isJumping) {
                state.verticalVelocity = CONFIG.jumpForce;
                state.isJumping = true;
            }

            state.playerGroup.position.y += state.verticalVelocity;
            state.verticalVelocity += CONFIG.gravity;

            if (state.playerGroup.position.y < 0) {
                state.playerGroup.position.y = 0;
                state.isJumping = false;
                state.verticalVelocity = 0;
            }

            return moving;
        }

        function updateLocalAnimation(moving) {
            if (state.isAttacking) {
                state.attackTimer += CONFIG.attackAnimSpeed;
                if (state.attackTimer > Math.PI) {
                    state.isAttacking = false;
                }
            }

            animateLimb(
                state.playerGroup.userData.limbs,
                moving && !state.isJumping,
                state.animTime,
                state.isAttacking,
                state.attackTimer
            );
        }

        function updateCamera() {
            camera.position.x = state.playerGroup.position.x + Math.sin(state.camAngle) * CONFIG.camDist;
            camera.position.z = state.playerGroup.position.z + Math.cos(state.camAngle) * CONFIG.camDist;
            camera.position.y = state.playerGroup.position.y + CONFIG.camHeight;
            camera.lookAt(
                state.playerGroup.position.x,
                state.playerGroup.position.y + 1.5,
                state.playerGroup.position.z
            );
        }

        function updateRemotePlayers() {
            for (const id in state.otherPlayers) {
                const other = state.otherPlayers[id];
                const mesh = other.mesh;

                const dist = Math.hypot(other.targetX - mesh.position.x, other.targetZ - mesh.position.z);
                const isMoving = dist > 0.1;

                mesh.position.x = lerp(mesh.position.x, other.targetX, CONFIG.interpFactor);
                mesh.position.z = lerp(mesh.position.z, other.targetZ, CONFIG.interpFactor);
                mesh.rotation.y = lerpAngle(mesh.rotation.y, other.targetRot, CONFIG.interpFactor);

                animateLimb(mesh.userData.limbs, isMoving, state.animTime, false, 0);

                const tempV = new THREE.Vector3(mesh.position.x, mesh.position.y + 2, mesh.position.z);
                tempV.project(camera);
                const x = (tempV.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(tempV.y * 0.5) + 0.5) * window.innerHeight;

                other.label.style.display = Math.abs(tempV.z) > 1 ? 'none' : 'block';
                other.label.style.left = `${x}px`;
                other.label.style.top = `${y}px`;
            }
        }

        function performAttack() {
            if (state.isAttacking || !state.isCharacterReady) return;

            state.isAttacking = true;
            state.attackTimer = 0;

            const dist = state.playerGroup.position.distanceTo(dummyGroup.position);
            if (dist < CONFIG.attackRange) {
                addLog("HIT! Dano causado.", "log-hit");
                targetCenter.material.color.setHex(0x550000);
                setTimeout(() => targetCenter.material.color.setHex(0xFF0000), 150);
            } else {
                addLog("Errou o alvo.", "log-miss");
            }

            state.blockSync = true;
            window.location.href = `byond://?src=${BYOND_REF}&action=attack`;
            setTimeout(() => {
                state.blockSync = false;
            }, 200);
        }

        // Fun√ß√£o Principal de Rede
        function receberDadosMultiplayer(json) {
            const packet = JSON.parse(json);
            const me = packet.me;
            state.myID = packet.my_id;

            if (me.loaded == 1 && !state.isCharacterReady) {
                initLocalPlayer(packet);
            }

            if (state.isCharacterReady) {
                updateHud(packet, me);
            }

            updateRemoteTargets(packet.others);
        }

        // --- 5. INPUTS E CONTROLE ---
        document.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if (Object.prototype.hasOwnProperty.call(INPUT_KEYS, k)) {
                INPUT_KEYS[k] = true;
            }

            if (k === 'a') {
                performAttack();
            }

            if (k === 'p' && !state.blockSync) {
                state.blockSync = true;
                window.location.href = `byond://?src=${BYOND_REF}&action=force_save`;
                addLog("Salvando...", "log-miss");
                setTimeout(() => {
                    state.blockSync = false;
                }, 500);
            }
        });

        document.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if (Object.prototype.hasOwnProperty.call(INPUT_KEYS, k)) {
                INPUT_KEYS[k] = false;
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());
        document.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                state.mouseRight = true;
                state.lastMouseX = e.clientX;
            }
        });
        document.addEventListener('mouseup', (e) => {
            if (e.button === 2) {
                state.mouseRight = false;
            }
        });
        document.addEventListener('mousemove', (e) => {
            if (state.mouseRight) {
                state.camAngle -= (e.clientX - state.lastMouseX) * 0.005;
                state.lastMouseX = e.clientX;
            }
        });

        setInterval(() => {
            if (state.isCharacterReady && !state.blockSync) {
                const x = state.playerGroup.position.x.toFixed(2);
                const z = state.playerGroup.position.z.toFixed(2);
                const rot = state.playerGroup.rotation.y.toFixed(2);
                window.location.href = `byond://?src=${BYOND_REF}&action=update_pos&x=${x}&z=${z}&rot=${rot}`;
            }
        }, CONFIG.syncIntervalMs);

        // --- 6. GAME LOOP & ANIMA√á√ÉO ---
        function animate() {
            requestAnimationFrame(animate);
            state.animTime += CONFIG.animTimeStep;

            if (state.isCharacterReady) {
                const moving = moveLocalPlayer();
                updateLocalAnimation(moving);
                updateCamera();
            }

            updateRemotePlayers();
            renderer.render(scene, camera);
        }

        animate();

        window.onresize = () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        };
    </script>
</body>
</html>