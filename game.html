<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        const BYOND_REF = "{{BYOND_REF}}";
    </script>
</head>
<body>
    <div id="ui-layer">
        <div class="char-info">
            <div id="name-display" style="font-size: 18px; font-weight: bold;">Loading...</div>
            <div style="font-size: 12px; color: #aaa;">Lvl <span id="lvl-display">0</span></div>
            <div class="bar-container"><div id="hp-bar-fill" class="hp-bar"></div></div>
            <div style="margin-top:5px; color:#f1c40f">ðŸ’° <span id="gold-display">0</span> Berries</div>
        </div>
        <div id="notif-area"></div>
        <div id="combat-log">System: Multiplayer Core Active.<br></div>
        <div id="labels-container"></div>
    </div>

    <script src="graphics.js"></script>
    <script src="animation.js"></script>
    <script src="network.js"></script>

    <script>
        // --- LÃ“GICA DO JOGO (CONTROLLER) ---
        
        const keys = { arrowup: false, arrowdown: false, arrowleft: false, arrowright: false, " ": false };
        let charState = "SWORD_IDLE"; 
        
        let camAngle = Math.PI; 
        let mouseRight = false; let lastMouseX = 0;
        
        document.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('mousedown', e => { if(e.button===2){mouseRight=true; lastMouseX=e.clientX;} });
        document.addEventListener('mouseup', e => { if(e.button===2) mouseRight=false; });
        document.addEventListener('mousemove', e => { if(mouseRight) { camAngle -= (e.clientX - lastMouseX)*0.005; lastMouseX=e.clientX; } });

        document.addEventListener('keydown', e => { 
            const k = e.key.toLowerCase(); if(keys.hasOwnProperty(k)) keys[k] = true;
            if(k === 'a') performAttack();
            if(k === 'p' && !blockSync) {
                blockSync = true; 
                window.location.href = "byond://?src=" + BYOND_REF + "&action=force_save";
                addLog("Salvando...", "log-miss");
                setTimeout(() => { blockSync = false; }, 500);
            }
        });
        document.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });

        function addLog(msg, css) { const d = document.getElementById('combat-log'); d.innerHTML += `<span class="${css}">${msg}</span><br>`; d.scrollTop=d.scrollHeight; }

        let animTime = 0; let isJumping = false; let verticalVelocity = 0; const gravity = -0.015; const jumpForce = 0.3;
        let isAttacking = false; 

        function performAttack() {
            if(isAttacking || !isCharacterReady) return; 
            isAttacking = true;
            charState = "SWORD_WINDUP"; 
            setTimeout(() => {
                charState = "SWORD_ATK_1"; 
                const dist = playerGroup.position.distanceTo(dummyGroup.position);
                if(dist < 2.5) { 
                    addLog("HIT! Dano causado.", "log-hit"); 
                    targetCenter.material.color.setHex(0x550000); setTimeout(()=>targetCenter.material.color.setHex(0xFF0000),150);
                } else addLog("Vento cortante...", "log-miss");
                
                blockSync = true; 
                window.location.href = "byond://?src=" + BYOND_REF + "&action=attack"; 
                setTimeout(()=>{blockSync=false}, 200);

                setTimeout(() => {
                    charState = "SWORD_IDLE"; 
                    isAttacking = false;
                }, 300);
            }, 100); 
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            animTime += 0.1;
            const now = performance.now();

            if (isCharacterReady) {
                const speed = 0.15;
                let moveX = 0, moveZ = 0, moving = false;
                const sin = Math.sin(camAngle); const cos = Math.cos(camAngle);
                
                if(keys.arrowup) { moveX -= sin*speed; moveZ -= cos*speed; moving = true; }
                if(keys.arrowdown) { moveX += sin*speed; moveZ += cos*speed; moving = true; }
                if(keys.arrowleft) { moveX -= cos*speed; moveZ += sin*speed; moving = true; }
                if(keys.arrowright) { moveX += cos*speed; moveZ -= sin*speed; moving = true; }

                playerGroup.position.x += moveX; playerGroup.position.z += moveZ;
                if(playerGroup.position.x > 30) playerGroup.position.x = 30; if(playerGroup.position.x < -30) playerGroup.position.x = -30;
                if(playerGroup.position.z > 30) playerGroup.position.z = 30; if(playerGroup.position.z < -30) playerGroup.position.z = -30;

                if(moving) {
                    const targetCharRot = Math.atan2(moveX, moveZ);
                    playerGroup.rotation.y = targetCharRot;
                    if(!keys.arrowdown && !mouseRight) camAngle = lerpAngle(camAngle, targetCharRot + Math.PI, 0.02);
                }

                if(keys[" "] && !isJumping) { verticalVelocity = jumpForce; isJumping = true; }
                playerGroup.position.y += verticalVelocity; verticalVelocity += gravity;
                if(playerGroup.position.y < 0) { playerGroup.position.y = 0; isJumping = false; verticalVelocity = 0; }

                let targetStance = STANCES[charState] || STANCES.DEFAULT;

                if(moving && !isJumping && !isAttacking) {
                    playerGroup.userData.limbs.leftLeg.rotation.x = Math.sin(animTime)*0.8;
                    playerGroup.userData.limbs.rightLeg.rotation.x = -Math.sin(animTime)*0.8;
                    
                    if(charState === "SWORD_IDLE") {
                        lerpLimbRotation(playerGroup.userData.limbs.leftArm, targetStance.leftArm, 0.2);
                        lerpLimbRotation(playerGroup.userData.limbs.rightArm, targetStance.rightArm, 0.2);
                    } else {
                        playerGroup.userData.limbs.leftArm.rotation.x = -Math.sin(animTime)*0.8;
                        playerGroup.userData.limbs.rightArm.rotation.x = Math.sin(animTime)*0.8;
                    }
                } else {
                    const animSpeed = isAttacking ? 0.4 : 0.1;
                    lerpLimbRotation(playerGroup.userData.limbs.leftArm, targetStance.leftArm, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.rightArm, targetStance.rightArm, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.leftLeg, targetStance.leftLeg, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.rightLeg, targetStance.rightLeg, animSpeed);
                }

                const camDist = 7; const camH = 5;
                camera.position.set(playerGroup.position.x + Math.sin(camAngle)*camDist, playerGroup.position.y + camH, playerGroup.position.z + Math.cos(camAngle)*camDist);
                camera.lookAt(playerGroup.position.x, playerGroup.position.y + 1.5, playerGroup.position.z);

                sendPositionUpdate(now);
            }

            // --- CORREÃ‡ÃƒO: AnimaÃ§Ã£o dos Outros Jogadores ---
            for(const id in otherPlayers) {
                const other = otherPlayers[id];
                const mesh = other.mesh;
                const elapsed = other.lastPacketTime ? (now - other.lastPacketTime) : 0;
                const t = other.lerpDuration ? Math.min(1, elapsed / other.lerpDuration) : 1;
                
                // Movimento da Malha (Interpolado)
                mesh.position.x = lerp(other.startX, other.targetX, t);
                mesh.position.y = lerp(other.startY, other.targetY, t);
                mesh.position.z = lerp(other.startZ, other.targetZ, t);
                mesh.rotation.y = lerpAngle(other.startRot, other.targetRot, t);

                // 1. Detectar se estÃ¡ se movendo (Calculamos a distÃ¢ncia entre onde ele estÃ¡ e onde quer ir)
                const dist = Math.sqrt(Math.pow(other.targetX - mesh.position.x, 2) + Math.pow(other.targetZ - mesh.position.z, 2));
                const isMoving = dist > 0.05; // Se a diferenÃ§a for maior que 0.05, consideramos que estÃ¡ andando

                // 2. Definir Postura Base (Assumimos que todos usam Espada por enquanto)
                let remoteStance = STANCES.SWORD_IDLE; 

                // 3. Aplicar AnimaÃ§Ã£o
                if(other.attacking) {
                    // Se estiver atacando (sinal simples do servidor)
                    // Usamos uma mistura visual para simular o ataque
                    mesh.userData.limbs.rightArm.rotation.x = lerp(mesh.userData.limbs.rightArm.rotation.x, STANCES.SWORD_ATK_1.rightArm.x, 0.2);
                    mesh.userData.limbs.leftArm.rotation.x = lerp(mesh.userData.limbs.leftArm.rotation.x, STANCES.SWORD_ATK_1.leftArm.x, 0.2);
                } 
                else if(isMoving) {
                    // Se estiver andando: Pernas balanÃ§am, BraÃ§os mantÃªm a guarda
                    mesh.userData.limbs.leftLeg.rotation.x = Math.sin(animTime)*0.8;
                    mesh.userData.limbs.rightLeg.rotation.x = -Math.sin(animTime)*0.8;
                    
                    // Suaviza os braÃ§os para a posiÃ§Ã£o de guarda (IDLE)
                    lerpLimbRotation(mesh.userData.limbs.leftArm, remoteStance.leftArm, 0.2);
                    lerpLimbRotation(mesh.userData.limbs.rightArm, remoteStance.rightArm, 0.2);
                } 
                else {
                    // Se estiver parado: Volta tudo suavemente para a postura IDLE
                    lerpLimbRotation(mesh.userData.limbs.leftArm, remoteStance.leftArm, 0.1);
                    lerpLimbRotation(mesh.userData.limbs.rightArm, remoteStance.rightArm, 0.1);
                    lerpLimbRotation(mesh.userData.limbs.leftLeg, remoteStance.leftLeg, 0.1);
                    lerpLimbRotation(mesh.userData.limbs.rightLeg, remoteStance.rightLeg, 0.1);
                }
                
                // Etiqueta de Nome
                const tempV = new THREE.Vector3(mesh.position.x, mesh.position.y + 2, mesh.position.z);
                tempV.project(camera);
                other.label.style.display = (Math.abs(tempV.z) > 1) ? 'none' : 'block';
                other.label.style.left = (tempV.x * .5 + .5) * window.innerWidth + 'px';
                other.label.style.top = (-(tempV.y * .5) + .5) * window.innerHeight + 'px';
            }

            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => { renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); };
    </script>
</body>
</html>