<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        const BYOND_REF = "{{BYOND_REF}}";
    </script>
</head>
<body>
    <div id="ui-layer">
        <div class="char-info">
            <div id="name-display" style="font-size: 18px; font-weight: bold;">Loading...</div>
            <div style="font-size: 12px; color: #aaa;">Lvl <span id="lvl-display">0</span></div>
            <div class="bar-container"><div id="hp-bar-fill" class="hp-bar"></div></div>
            <div style="margin-top:5px; color:#f1c40f">ðŸ’° <span id="gold-display">0</span> Berries</div>
        </div>
        <div id="notif-area"></div>
        <div id="combat-log">System: Multiplayer Core Active.<br></div>
        <div id="labels-container"></div>
    </div>

    <script src="graphics.js"></script>
    <script src="animation.js"></script>
    <script src="network.js"></script>

    <script>
        // --- LÃ“GICA DO JOGO (CONTROLLER) ---
        
        const keys = { arrowup: false, arrowdown: false, arrowleft: false, arrowright: false, " ": false };
        
        let charState = "DEFAULT"; // ComeÃ§a relaxado
        let currentCombatMode = "DEFAULT"; // Rastreia qual a postura de combate atual (FIST, SWORD, etc)
        let lastCombatActionTime = 0; // Para voltar ao relaxado

        let camAngle = Math.PI; 
        let mouseRight = false; let lastMouseX = 0;
        
        document.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('mousedown', e => { if(e.button===2){mouseRight=true; lastMouseX=e.clientX;} });
        document.addEventListener('mouseup', e => { if(e.button===2) mouseRight=false; });
        document.addEventListener('mousemove', e => { if(mouseRight) { camAngle -= (e.clientX - lastMouseX)*0.005; lastMouseX=e.clientX; } });

        document.addEventListener('keydown', e => { 
            const k = e.key.toLowerCase(); if(keys.hasOwnProperty(k)) keys[k] = true;
            
            // MAPA DE ATAQUES
            if(k === 'a') performAttack("fist");
            if(k === 's') performAttack("kick");
            if(k === 'd') performAttack("sword");
            if(k === 'f') performAttack("gun");

            if(k === 'p' && !blockSync) {
                blockSync = true; 
                window.location.href = "byond://?src=" + BYOND_REF + "&action=force_save";
                addLog("Salvando...", "log-miss");
                setTimeout(() => { blockSync = false; }, 500);
            }
        });
        document.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.key.toLowerCase())) keys[e.key.toLowerCase()] = false; });

        function addLog(msg, css) { const d = document.getElementById('combat-log'); d.innerHTML += `<span class="${css}">${msg}</span><br>`; d.scrollTop=d.scrollHeight; }

        let animTime = 0; let isJumping = false; let verticalVelocity = 0; const gravity = -0.015; const jumpForce = 0.3;
        let isAttacking = false; 

        function performAttack(type) {
            if(isAttacking || !isCharacterReady) return; 
            
            isAttacking = true;
            lastCombatActionTime = Date.now(); // Reseta timer de relaxamento

            // Define posturas baseadas no tipo
            let windupStance = "SWORD_WINDUP";
            let atkStance = "SWORD_ATK_1";
            let idleStance = "SWORD_IDLE";

            if(type === "fist") {
                windupStance = "FIST_WINDUP"; atkStance = "FIST_ATK"; idleStance = "FIST_IDLE";
                currentCombatMode = "FIST_IDLE";
            }
            else if(type === "kick") {
                windupStance = "KICK_WINDUP"; atkStance = "KICK_ATK"; idleStance = "FIST_IDLE"; // Volta para guarda de soco
                currentCombatMode = "FIST_IDLE";
            }
            else if(type === "sword") {
                windupStance = "SWORD_WINDUP"; atkStance = "SWORD_ATK_1"; idleStance = "SWORD_IDLE";
                currentCombatMode = "SWORD_IDLE";
            }
            else if(type === "gun") {
                windupStance = "GUN_IDLE"; atkStance = "GUN_ATK"; idleStance = "GUN_IDLE";
                currentCombatMode = "GUN_IDLE";
            }

            charState = windupStance; 

            setTimeout(() => {
                charState = atkStance;
                
                // Dano (simplificado)
                const dist = playerGroup.position.distanceTo(dummyGroup.position);
                if(dist < (type === "gun" ? 8.0 : 2.5)) { // Arma tem alcance maior
                    addLog(`HIT (${type})!`, "log-hit"); 
                    targetCenter.material.color.setHex(0x550000); setTimeout(()=>targetCenter.material.color.setHex(0xFF0000),150);
                } else {
                    addLog("Errou...", "log-miss");
                }
                
                // Envia ao servidor COM O TIPO
                blockSync = true; 
                window.location.href = `byond://?src=${BYOND_REF}&action=attack&type=${type}`; 
                setTimeout(()=>{blockSync=false}, 200);

                setTimeout(() => {
                    charState = idleStance; // Volta para guarda de combate
                    isAttacking = false;
                }, 300); // Tempo do golpe
            }, 100); // Tempo do windup
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);
            animTime += 0.1;
            const now = performance.now();

            if (isCharacterReady) {
                // LÃ“GICA DE ESTADO (Combate vs Relaxado)
                // Se nÃ£o atacou nos Ãºltimos 3000ms, volta para DEFAULT
                if(!isAttacking && charState !== "DEFAULT") {
                    if(Date.now() - lastCombatActionTime > 3000) {
                        charState = "DEFAULT";
                    }
                }

                const speed = 0.15;
                let moveX = 0, moveZ = 0, moving = false;
                const sin = Math.sin(camAngle); const cos = Math.cos(camAngle);
                
                if(keys.arrowup) { moveX -= sin*speed; moveZ -= cos*speed; moving = true; }
                if(keys.arrowdown) { moveX += sin*speed; moveZ += cos*speed; moving = true; }
                if(keys.arrowleft) { moveX -= cos*speed; moveZ += sin*speed; moving = true; }
                if(keys.arrowright) { moveX += cos*speed; moveZ -= sin*speed; moving = true; }

                playerGroup.position.x += moveX; playerGroup.position.z += moveZ;
                if(playerGroup.position.x > 30) playerGroup.position.x = 30; if(playerGroup.position.x < -30) playerGroup.position.x = -30;
                if(playerGroup.position.z > 30) playerGroup.position.z = 30; if(playerGroup.position.z < -30) playerGroup.position.z = -30;

                if(moving) {
                    const targetCharRot = Math.atan2(moveX, moveZ);
                    playerGroup.rotation.y = targetCharRot;
                    if(!keys.arrowdown && !mouseRight) camAngle = lerpAngle(camAngle, targetCharRot + Math.PI, 0.02);
                }

                if(keys[" "] && !isJumping) { verticalVelocity = jumpForce; isJumping = true; }
                playerGroup.position.y += verticalVelocity; verticalVelocity += gravity;
                if(playerGroup.position.y < 0) { playerGroup.position.y = 0; isJumping = false; verticalVelocity = 0; }

                // --- ANIMAÃ‡ÃƒO LOCAL ---
                let targetStance = STANCES[charState] || STANCES.DEFAULT;

                if(moving && !isJumping && !isAttacking) {
                    playerGroup.userData.limbs.leftLeg.rotation.x = Math.sin(animTime)*0.8;
                    playerGroup.userData.limbs.rightLeg.rotation.x = -Math.sin(animTime)*0.8;
                    
                    if(charState === "DEFAULT") {
                        playerGroup.userData.limbs.leftArm.rotation.x = -Math.sin(animTime)*0.8;
                        playerGroup.userData.limbs.rightArm.rotation.x = Math.sin(animTime)*0.8;
                    } else {
                        lerpLimbRotation(playerGroup.userData.limbs.leftArm, targetStance.leftArm, 0.2);
                        lerpLimbRotation(playerGroup.userData.limbs.rightArm, targetStance.rightArm, 0.2);
                    }
                } else {
                    const animSpeed = isAttacking ? 0.4 : 0.1;
                    lerpLimbRotation(playerGroup.userData.limbs.leftArm, targetStance.leftArm, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.rightArm, targetStance.rightArm, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.leftLeg, targetStance.leftLeg, animSpeed);
                    lerpLimbRotation(playerGroup.userData.limbs.rightLeg, targetStance.rightLeg, animSpeed);
                }

                const camDist = 7; const camH = 5;
                camera.position.set(playerGroup.position.x + Math.sin(camAngle)*camDist, playerGroup.position.y + camH, playerGroup.position.z + Math.cos(camAngle)*camDist);
                camera.lookAt(playerGroup.position.x, playerGroup.position.y + 1.5, playerGroup.position.z);

                sendPositionUpdate(now);
            }

            // --- ANIMAÃ‡ÃƒO DOS OUTROS (CORRIGIDO COM MEMÃ“RIA) ---
            for(const id in otherPlayers) {
                const other = otherPlayers[id];
                const mesh = other.mesh;
                const elapsed = other.lastPacketTime ? (now - other.lastPacketTime) : 0;
                const t = other.lerpDuration ? Math.min(1, elapsed / other.lerpDuration) : 1;
                
                mesh.position.x = lerp(other.startX, other.targetX, t);
                mesh.position.y = lerp(other.startY, other.targetY, t);
                mesh.position.z = lerp(other.startZ, other.targetZ, t);
                mesh.rotation.y = lerpAngle(other.startRot, other.targetRot, t);

                const dist = Math.sqrt(Math.pow(other.targetX - mesh.position.x, 2) + Math.pow(other.targetZ - mesh.position.z, 2));
                const isMoving = dist > 0.05;

                // --- NOVA LÃ“GICA DE POSTURA REMOTA ---
                let remoteStance = STANCES.DEFAULT; 
                
                // Verifica se estÃ¡ em "Modo de Combate" (menos de 3s desde o Ãºltimo ataque)
                const timeSinceCombat = now - (other.lastCombatTime || 0);
                const isInCombatMode = timeSinceCombat < 3000;

                if(isInCombatMode) {
                    // Seleciona a postura de IDLE baseada no Ãºltimo tipo de ataque conhecido
                    let type = other.lastCombatType || "sword";
                    if(type === "fist" || type === "kick") remoteStance = STANCES.FIST_IDLE;
                    else if(type === "gun") remoteStance = STANCES.GUN_IDLE;
                    else remoteStance = STANCES.SWORD_IDLE;
                }

                if(other.attacking) {
                    // SE ESTIVER ATACANDO (AnimaÃ§Ã£o ativa)
                    let atkName = "SWORD_ATK_1";
                    // Usa attackType atual ou o da memÃ³ria se falhar
                    let currentType = other.attackType || other.lastCombatType;

                    if(currentType === "fist") atkName = "FIST_ATK";
                    if(currentType === "kick") atkName = "KICK_ATK";
                    if(currentType === "gun") atkName = "GUN_ATK";
                    
                    let targetAnim = STANCES[atkName] || STANCES.SWORD_ATK_1;

                    lerpLimbRotation(mesh.userData.limbs.leftArm, targetAnim.leftArm, 0.3);
                    lerpLimbRotation(mesh.userData.limbs.rightArm, targetAnim.rightArm, 0.3);
                    lerpLimbRotation(mesh.userData.limbs.leftLeg, targetAnim.leftLeg, 0.3);
                    lerpLimbRotation(mesh.userData.limbs.rightLeg, targetAnim.rightLeg, 0.3);
                } else {
                    // SE NÃƒO ESTIVER ATACANDO (Usa a remoteStance que calculamos acima)
                    if(isMoving) {
                        mesh.userData.limbs.leftLeg.rotation.x = Math.sin(animTime)*0.8;
                        mesh.userData.limbs.rightLeg.rotation.x = -Math.sin(animTime)*0.8;
                        
                        if(remoteStance === STANCES.DEFAULT) {
                            mesh.userData.limbs.leftArm.rotation.x = -Math.sin(animTime)*0.8;
                            mesh.userData.limbs.rightArm.rotation.x = Math.sin(animTime)*0.8;
                        } else {
                            // MantÃ©m a guarda enquanto anda
                            lerpLimbRotation(mesh.userData.limbs.leftArm, remoteStance.leftArm, 0.2);
                            lerpLimbRotation(mesh.userData.limbs.rightArm, remoteStance.rightArm, 0.2);
                        }
                    } else {
                        // Parado
                        lerpLimbRotation(mesh.userData.limbs.leftArm, remoteStance.leftArm, 0.1);
                        lerpLimbRotation(mesh.userData.limbs.rightArm, remoteStance.rightArm, 0.1);
                        lerpLimbRotation(mesh.userData.limbs.leftLeg, remoteStance.leftLeg, 0.1);
                        lerpLimbRotation(mesh.userData.limbs.rightLeg, remoteStance.rightLeg, 0.1);
                    }
                }
                
                const tempV = new THREE.Vector3(mesh.position.x, mesh.position.y + 2, mesh.position.z);
                tempV.project(camera);
                other.label.style.display = (Math.abs(tempV.z) > 1) ? 'none' : 'block';
                other.label.style.left = (tempV.x * .5 + .5) * window.innerWidth + 'px';
                other.label.style.top = (-(tempV.y * .5) + .5) * window.innerHeight + 'px';
            }

            renderer.render(scene, camera);
        }
        animate();
        window.onresize = () => { renderer.setSize(window.innerWidth, window.innerHeight); camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); };
    </script>
</body>
</html>